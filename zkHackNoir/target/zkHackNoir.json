{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":6937114681692406931,"abi":{"parameters":[{"name":"target_chromosome","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"target_position","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"target_ref_allele","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"target_alt_allele","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"participant1","type":{"kind":"struct","path":"ParticipantData","fields":[{"name":"chromosome","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"position","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"ref_allele","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"alt_allele","type":{"kind":"integer","sign":"unsigned","width":8}}]},"visibility":"private"},{"name":"participant2","type":{"kind":"struct","path":"ParticipantData","fields":[{"name":"chromosome","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"position","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"ref_allele","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"alt_allele","type":{"kind":"integer","sign":"unsigned","width":8}}]},"visibility":"private"}],"return_type":null,"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"}}},"bytecode":"H4sIAAAAAAAA/9VaS1LbQBBtSRhsHAgONr/wcSCYeKexJCztuAou5LPkADlETpJNFlwJN2igaxjY+HWVpqtUY89Iz6+f9aRRjyJ6ielqmzefo9WWNC3H2OmLPH3xaus6fYmnb8NzbMfTt+k5dsvT1/Uc2/P0bXuO7Td9MpKmvWvadL0wEitLb/O8ns9qk5n7dFYtyiLNi8VtaUpTlMXDrMyyuszLebWo5mll8qw2y6LKlg3YBhDrCy7HZ172vHEjAuuJ5C357mgS3lHA3QWeDFp57wqBQbipgISbNQJq2gFifaUwzYrkLfnuaRLeU8AdULvNynkPhMAgXFWzxkBNN4FY3yhMsyJ5S777moT3FXCH1G6zct5DITAIV9WsCVDTLSDWiMI0K5K35HugSfhAAfeQ2m1WzvtQCAzCVeHK0/WBB3ddXY9anjdfTI8U8j4mrElt3YJxbd1Cw0/HClqcKGlxQmHVcLpArO8U5s0LyVvyPdUkfKqAe0btvnlx3mdCYBBuMDWcHhDrnMI0K5K35HuhSfhCAXdM7TYr5z0WAoNwg6nhbAOxflCYZkXylnwvNQlfKuBeUbvNynlfCYFBuMHUcPpArJ8UplmRvCXfa03C1wq4E2q3WTnviRAYhKvClafrY8I/v9+0PG++mN4o5P2LsCa1dQvG1arhTBp8tBZTJS2m9L6GE4M1AdafzBSgab18CftOFAkN+Du/PsCrkvadJ34U5RluX+xvz52Y3m725IyfN+3/P4///v6+fxBDr08LvrHsk7HigzF7vvWcdiTG5SQiXS+MxR/q4D8vNLkxEp+HTp6xGLsDcbB49v/t0PuInTG7b9fhF+H5GZdL4vktG3YlWC5eWj2fAJQMoVqIKAAA","debug_symbols":"tdfJasMwEAbgd9HZB+2LX6WU4DUIjG28FIrJu9cOEbhO60OU/+bRzHwXMR60kLLK5+vFt3U3kvRjIU1XZJPv2jVaCOP3s7HP2i0cp2yYSMqYcAmp2nL71PKWkNo3FUk1vyVPxYaGWqP4vvQzIUxgeYnlFZbX8bzVj1rL1ZE3WN5ieQflOY3mrQq1jh6vljMsz7G8wPLxU+tEuFpn3JFXWF5jeYPl46fWucAzKtjRd1hfULDP3upLcfQ52P9ndK0IPZza11eWkFheYXmN5U08f7KyhMXyDspLiuVZNH+2siTH8gLLSywfP7VnK0tqLG+wvMXy8VN7ug8VBfsM7PO3+k/7Vgmw//foKm1CjzK//4VrkA++afz1sn/pr8df2eCzvKkeYT23xS47ffchE/r7oSuqch6qTbrnVv4H","file_map":{"62":{"source":"// Define a struct for participant genomic data (private)\nstruct ParticipantData {\n    chromosome: u32,\n    position: u32,\n    ref_allele: u8, // Encoded as 0=A, 1=T, 2=C, 3=G\n    alt_allele: u8,\n}\n\n// Main circuit for 2 participants (adjust size as needed)\nfn main(\n    // Public inputs: Target variant details\n    target_chromosome: pub u32,\n    target_position: pub u32,\n    target_ref_allele: pub u8,\n    target_alt_allele: pub u8,\n\n    // Private inputs: Genomic data for participants\n    participant1: ParticipantData,\n    participant2: ParticipantData,\n) {\n    // Check if a participant matches the target variant\n    let check_match = |participant: ParticipantData| -> u8 {\n        let chrom_match = (participant.chromosome == target_chromosome) as u8;\n        let pos_match = (participant.position == target_position) as u8;\n        let ref_match = (participant.ref_allele == target_ref_allele) as u8;\n        let alt_match = (participant.alt_allele == target_alt_allele) as u8;\n        chrom_match * pos_match * ref_match * alt_match // Returns 1 if all match\n    };\n\n    // Compute matches for each participant\n    let match1 = check_match(participant1);\n    let match2 = check_match(participant2);\n\n    // Sum all matches (at least 1 must be non-zero)\n    let sum = match1 + match2;\n\n    //previous code:\n    // Enforce sum != 0 using modular inverse trick\n    // let inv = 1 / sum; \n    // Fails if sum = 0 (no match)\n    // assert(inv * sum == 1); // Valid only if sum != 0\n    //\n\n    // Enforce that both participants match (sum must be 2)\n    assert(sum == 2); // Valid only if both participants match\n}\n","path":"/mnt/e/zk-hack-tri/zkHackNoir/src/main.nr"}},"names":["main"],"brillig_names":["directive_invert"]}